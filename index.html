<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8" />
  <title>Interview Coder</title>
  <link rel="stylesheet" href="styles.css">
</head>

<body>
  <!-- New horizontal floating toolbar at the top -->
  <div id="top-toolbar">
    <div class="toolbar-button" id="btn-toggle-visibility" title="Show/Hide (Cmd/Ctrl+B)">
      <span class="icon">üëÅÔ∏è</span>
      <span>Show/Hide</span>
      <span class="shortcut" id="toggle-shortcut">‚åò B</span>
    </div>

    <div class="toolbar-button" id="btn-process" title="Process Screenshots (Cmd/Ctrl+Enter)">
      <span class="icon">üì∏</span>
      <span>Process Images</span>
      <span class="shortcut" id="process-shortcut">‚åò ‚Üµ</span>
    </div>

    <div class="toolbar-button" id="btn-auto-screenshot" title="Screenshot & Process (Cmd/Ctrl+H)">
      <span class="icon">üì∑</span>
      <span>Auto Screenshot</span>
      <span class="shortcut">‚åò H</span>
    </div>

    <div class="toolbar-button" id="btn-reset" title="Reset (Cmd/Ctrl+R)">
      <span class="icon">üîÑ</span>
      <span>Start Over</span>
      <span class="shortcut" id="reset-shortcut">‚åò R</span>
    </div>

    <div class="toolbar-button" id="btn-settings" title="Settings (Cmd/Ctrl+,)">
      <span class="icon">‚öôÔ∏è</span>
      <span>Settings</span>
      <span class="shortcut">‚åò ,</span>
    </div>
  </div>

  <!-- Content container to separate from toolbar -->
  <div id="content-container">
    <div id="instruction-banner"></div>

    <div id="main-content">
      <!-- Loading skeleton -->
      <div id="loading-content" class="loading-container" style="display: none;">
        <!-- Section 1: Analyzing the Problem -->
        <div class="skeleton-section">
          <div class="skeleton-header"></div>
          <div class="skeleton-text line-90"></div>
          <div class="skeleton-text line-80"></div>
          <div class="skeleton-text line-90"></div>
        </div>

        <!-- Section 2: My thoughts -->
        <div class="skeleton-section">
          <div class="skeleton-header"></div>
          <div class="skeleton-text line-90"></div>
          <div class="skeleton-text line-80"></div>
          <div class="skeleton-code"></div>
          <div class="skeleton-text line-70"></div>
        </div>

        <!-- Section 3: Complexity -->
        <div class="skeleton-section">
          <div class="skeleton-header"></div>
          <div class="skeleton-text line-80"></div>
          <div class="skeleton-text line-90"></div>
        </div>
      </div>

      <!-- Result content -->
      <div id="result-content"></div>

      <!-- Continue with context button section -->
      <div id="context-actions" style="display: none;">
        <div class="toolbar-button" id="btn-add-context">
          <span class="icon">üì∑</span>
          <span>Add screenshot to continue</span>
        </div>
        <div class="toolbar-button" id="btn-report-error">
          <span class="icon">üîÑ</span>
          <span>Report error in solution</span>
        </div>
      </div>
    </div>

    <div id="model-badge" class="model-badge"></div>

    <div id="notification-container"></div>
  </div>

  <script>
    const { ipcRenderer } = require('electron');

    // Import remark and related packages
    let unified = null;
    let remarkParse = null;
    let remarkGfm = null;
    let remarkRehype = null;
    let rehypeStringify = null;
    let processor = null;

    try {
      // Use the Node.js require to import the installed packages

      try {
        const unifiedModule = require('unified');
        unified = unifiedModule.unified;
      } catch (err) {
        console.error("Failed to load unified:", err.message);
        throw err;
      }

      try {
        remarkParse = require('remark-parse').default;
        // If default is undefined, try using the module directly
        if (!remarkParse) {
          remarkParse = require('remark-parse');
        }
      } catch (err) {
        console.error("Failed to load remark-parse:", err.message);
        throw err;
      }

      try {
        remarkGfm = require('remark-gfm').default;
        // If default is undefined, try using the module directly
        if (!remarkGfm) {
          remarkGfm = require('remark-gfm');
        }
      } catch (err) {
        console.error("Failed to load remark-gfm:", err.message);
        throw err;
      }

      try {
        remarkRehype = require('remark-rehype').default;
        // If default is undefined, try using the module directly
        if (!remarkRehype) {
          remarkRehype = require('remark-rehype');
        }
      } catch (err) {
        console.error("Failed to load remark-rehype:", err.message);
        throw err;
      }

      try {
        rehypeStringify = require('rehype-stringify').default;
        // If default is undefined, try using the module directly
        if (!rehypeStringify) {
          rehypeStringify = require('rehype-stringify');
        }
      } catch (err) {
        console.error("Failed to load rehype-stringify:", err.message);
        throw err;
      }

      // Initialize unified processor pipeline
      processor = unified()
        .use(remarkParse)
        .use(remarkGfm)
        .use(remarkRehype, { allowDangerousHtml: true })
        .use(rehypeStringify);


      // Test with a small markdown string
      const testMarkdown = "# Test\n\nThis is a **test**";
      processor.process(testMarkdown)
        .catch(err => console.error("Test markdown processing failed:", err.message));
    } catch (e) {
      console.error("Error initializing unified processor:", e.message);
      console.error("Stack trace:", e.stack);

      // Create a very basic fallback processor
      processor = {
        process: async (markdown) => {
          // Very basic markdown processing as fallback
          console.warn("Using fallback markdown processor");
          const html = basicMarkdownProcess(markdown);
          // Return an object with a toString method to match unified's API
          return {
            toString: () => html,
            valueOf: () => html
          };
        }
      };
    }

    // Detect platform for correct key labels
    const isMac = navigator.platform.includes('Mac');
    const modifierKey = isMac ? 'Command' : 'Ctrl';

    // Application state
    let isWindowVisible = true;
    let debugMode = false; // Set to true for debugging

    // Toggle window visibility
    function toggleWindowVisibility() {
      // Simply notify main process about the visibility toggle request
      // Let main process handle the actual hiding/showing
      ipcRenderer.send('toggle-visibility');

      // Local state will be updated when we receive the update-visibility event
    }

    // Listen for main process messages
    ipcRenderer.on('update-instruction', (event, instruction) => {
      const banner = document.getElementById('instruction-banner');
      banner.innerHTML = instruction.replace(/\n/g, '<br>');
      banner.style.opacity = '1';
    });

    // Initialize context menu for element inspection
    document.addEventListener('contextmenu', (e) => {
      ipcRenderer.send('show-context-menu');
    });

    // Handle scroll-content event from main process
    ipcRenderer.on('scroll-content', (event, direction) => {
      const contentContainer = document.getElementById('content-container');
      const scrollAmount = 300; // Pixels to scroll in horizontal or vertical direction
      
      // Add a class to reduce rendering during programmatic scrolling
      contentContainer.classList.add('scrolling');
      
      // Temporarily disable smooth scrolling for better performance
      const currentScrollBehavior = contentContainer.style.scrollBehavior;
      contentContainer.style.scrollBehavior = 'auto';
      
      switch(direction) {
        case 'up':
          contentContainer.scrollBy({
            top: -scrollAmount,
            behavior: 'auto'
          });
          break;
        case 'down':
          contentContainer.scrollBy({
            top: scrollAmount,
            behavior: 'auto'
          });
          break;
        case 'left':
          contentContainer.scrollBy({
            left: -scrollAmount,
            behavior: 'auto'
          });
          break;
        case 'right':
          contentContainer.scrollBy({
            left: scrollAmount,
            behavior: 'auto'
          });
          break;
      }
      
      // Restore smooth scrolling after a delay
      setTimeout(() => {
        contentContainer.style.scrollBehavior = currentScrollBehavior;
        contentContainer.classList.remove('scrolling');
      }, 100);
    });

    // Register keyboard shortcut for DevTools (Cmd/Ctrl+Shift+I)
    document.addEventListener('keydown', (e) => {
      if ((isMac ? e.metaKey : e.ctrlKey) && e.shiftKey && e.key === 'I') {
        ipcRenderer.send('toggle-devtools');
        e.preventDefault();
      }
    });

    ipcRenderer.on('hide-instruction', () => {
      const banner = document.getElementById('instruction-banner');
      banner.style.opacity = '0';
    });

    ipcRenderer.on('update-visibility', (event, isVisible) => {
      isWindowVisible = isVisible;
      document.body.classList.toggle('invisible-mode', !isWindowVisible);
    });

    ipcRenderer.on('notification', (event, data) => {
      showNotification(data.body, data.type || 'success');
    });

    ipcRenderer.on('warning', (event, message) => {
      showNotification(message, 'warning');
    });

    ipcRenderer.on('error', (event, message) => {
      showNotification(message, 'error');
    });

    ipcRenderer.on('loading', (event, isLoading) => {
      document.getElementById('loading-content').style.display = isLoading ? 'flex' : 'none';
      document.getElementById('result-content').style.display = isLoading ? 'none' : 'block';

      // Show/hide context actions when not loading
      document.getElementById('context-actions').style.display = isLoading ? 'none' : 'flex';
    });

    ipcRenderer.on('analysis-result', async (event, markdown) => {
      const html = await processMarkdown(markdown);
      
      // Use optimized DOM updates
      requestAnimationFrame(() => {
        document.getElementById('result-content').innerHTML = html;

        // Show context actions 
        document.getElementById('context-actions').style.display = 'flex';

        // Setup code copy buttons after content is added
        setupCodeCopyButtons();

        // Optimize scroll performance after new content is loaded
        optimizeScrollPerformance();
      });

      // Scroll to top using optimized method
      requestAnimationFrame(() => {
        const contentContainer = document.getElementById('content-container');
        contentContainer.classList.add('scrolling');
        contentContainer.scrollTo(0, 0);
        
        setTimeout(() => {
          contentContainer.classList.remove('scrolling');
        }, 100);
      });
    });

    // Setup for streaming results
    ipcRenderer.on('stream-start', () => {
      document.getElementById('result-content').innerHTML = '';
      document.getElementById('context-actions').style.display = 'none';
    });

    // Track current markdown accumulation state for improved streaming
    let streamBuffer = '';
    let codeBlockType = null;
    let insideCodeBlock = false;

    ipcRenderer.on('stream-chunk', async (event, chunk) => {
      try {
        // Add chunk to buffer
        streamBuffer += chunk;

        // Process the full accumulated text to ensure proper markdown rendering
        const html = await processMarkdown(streamBuffer);
        
        // Use optimized DOM updates
        requestAnimationFrame(() => {
          document.getElementById('result-content').innerHTML = html;
        
          // Setup code copy buttons
          setupCodeCopyButtons();
        
          // Use optimized scrolling that prevents flickering
          safeScrollToBottom();
        });
      } catch (error) {
        console.error("Error processing stream chunk:", error);
        // Display error but continue operation
        document.getElementById('result-content').innerHTML += `<p class="error-message">Error rendering chunk: ${error.message}</p>`;
      }
    });

    ipcRenderer.on('stream-update', async (event, fullText) => {
      // Replace the content with the full updated text (better for Gemini streaming)
      try {
        // Update the stream buffer
        streamBuffer = fullText;

        // If the text is empty, don't process it
        if (!fullText || fullText.trim() === '') {
          return;
        }

        const html = await processMarkdown(fullText);
        
        // Use optimized DOM updates to prevent flickering
        requestAnimationFrame(() => {
          document.getElementById('result-content').innerHTML = html;
          
          // Setup code copy buttons after content is updated
          setupCodeCopyButtons();
          
          // Use optimized scrolling that prevents flickering
          safeScrollToBottom();
        });
      } catch (error) {
        console.error("Error processing stream update:", error);
        // Provide better error visualization
        document.getElementById('result-content').innerHTML = `
          <p class="error-message">Error rendering content: ${error.message}</p>
          <pre>${fullText.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</pre>
        `;
      }
    });

    ipcRenderer.on('stream-end', () => {
      // Streaming is complete, reset buffer
      streamBuffer = '';

      // Make sure all code blocks have copy buttons
      setupCodeCopyButtons();

      // Show context actions when streaming is complete
      document.getElementById('context-actions').style.display = 'flex';

      // Hide instruction banner when streaming is complete
      const banner = document.getElementById('instruction-banner');
      banner.style.opacity = '0';

      // Ensure visible content
      const contentContainer = document.getElementById('content-container');
      if (contentContainer.scrollHeight > contentContainer.clientHeight) {
        // Add a small delay to ensure DOM is ready
        setTimeout(() => {
          // If there's something to scroll to, add a small offset to ensure top content is visible
          contentContainer.scrollTo({ top: 0, behavior: 'smooth' });
        }, 100);
      }
    });

    ipcRenderer.on('clear-result', () => {
      document.getElementById('result-content').innerHTML = '';
      document.getElementById('context-actions').style.display = 'none';
    });

    // Update AI provider/model badge display
    ipcRenderer.on('model-changed', () => {
      updateModelBadge();
    });

    // Handle screen sharing detection
    ipcRenderer.on('screen-sharing-detected', () => {
      // Make the window nearly invisible
      isWindowVisible = false;
      document.body.classList.add('invisible-mode');

      // Show temporary notification
      showTemporaryNotification('Screen sharing detected - window hidden. Press ' + modifierKey + '+B to show.', 'warning');
    });

    // Update the model badge with current settings
    async function updateModelBadge() {
      try {
        let settings;

        try {
          settings = await ipcRenderer.invoke('get-current-settings');
        } catch (error) {
          console.error('Error getting model settings from main process:', error);

          // Try to get settings from localStorage as fallback
          try {
            const savedSettings = localStorage.getItem('model-settings');
            if (savedSettings) {
              settings = JSON.parse(savedSettings);
            } else {
              // Fallback to default settings
              settings = {
                aiProvider: 'openai',
                currentModel: 'gpt-4o-mini'
              };
            }
          } catch (localStorageErr) {
            console.error('Error retrieving from localStorage:', localStorageErr);
            // Fallback to default settings
            settings = {
              aiProvider: 'openai',
              currentModel: 'gpt-4o-mini'
            };
          }
        }

        const badge = document.getElementById('model-badge');

        let providerName = '';
        switch (settings.aiProvider) {
          case 'openai': providerName = 'OpenAI'; break;
          case 'ollama': providerName = 'Ollama'; break;
          case 'gemini': providerName = 'Gemini'; break;
          default: providerName = settings.aiProvider || 'AI';
        }

        const modelName = settings.currentModel || 'Default Model';
        badge.textContent = `${providerName}: ${modelName}`;

        // Save current settings to localStorage for persistence
        try {
          localStorage.setItem('model-settings', JSON.stringify(settings));
        } catch (err) {
          console.error('Error saving settings to localStorage:', err);
        }
      } catch (error) {
        console.error('Error updating model badge:', error);
        // Ensure badge always shows something useful even on complete failure
        const badge = document.getElementById('model-badge');
        badge.textContent = 'AI: Default Model';
      }
    }

    // Process markdown content to HTML using unified processor
    async function processMarkdown(markdown) {
      try {
        // Check if we have any content to process
        if (!markdown || markdown.trim() === '') {
          return '';
        }

        let html = '';

        if (processor) {
          // Use unified processor to process markdown
          try {
            const file = await processor.process(markdown);
            html = String(file);
          } catch (processingError) {
            console.error("Markdown processing error:", processingError);
            console.error("Error stack:", processingError.stack);

            // Attempt to fall back to basic processing
            html = basicMarkdownProcess(markdown);
          }
        } else {
          // Basic fallback markdown processing
          html = basicMarkdownProcess(markdown);
        }

        // If debug mode is on, add raw markdown visibility
        if (debugMode) {
          return `
            <div style="background: rgba(0,0,0,0.8); padding: 10px; margin-bottom: 10px; border-radius: 5px;">
              <details>
                <summary style="cursor: pointer; color: #ffcc00;">Debug: Raw Markdown (Click to expand)</summary>
                <pre style="max-height: 200px; overflow: auto; background: #222; padding: 10px; margin-top: 10px;">${markdown.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</pre>
              </details>
            </div>
            ${html}
          `;
        }

        // Create wrapper in memory to avoid DOM reflows
        const wrapper = document.createElement('div');
        wrapper.innerHTML = html;
        
        // Apply anti-flicker optimizations to elements
        wrapper.querySelectorAll('img').forEach(img => {
          img.style.transform = 'translateZ(0)';
          img.loading = 'lazy';
          // Set dimensions to prevent layout shifts
          if (!img.width && !img.height) {
            img.width = 600;
            img.height = 400;
          }
        });

        // Add compositing hints to headings
        wrapper.querySelectorAll('h1, h2, h3, h4, h5, h6').forEach(heading => {
          heading.style.transform = 'translateZ(0)';
        });

        // Find all pre > code elements and wrap them with copy button and language tag
        wrapper.querySelectorAll('pre > code').forEach(codeBlock => {
          const pre = codeBlock.parentNode;
          const container = document.createElement('div');
          container.className = 'code-block-container';
          
          // Apply compositing optimization
          container.style.transform = 'translateZ(0)';
          container.style.contain = 'content';

          // Create copy button
          const copyButton = document.createElement('button');
          copyButton.className = 'copy-code-button';
          copyButton.textContent = 'Copy';
          copyButton.setAttribute('data-has-listener', 'true');

          // Extract language from class
          let language = '';
          if (codeBlock.className) {
            const langMatch = codeBlock.className.match(/language-(\w+)/);
            if (langMatch && langMatch[1]) {
              language = langMatch[1];

              // Create language tag
              const langTag = document.createElement('div');
              langTag.className = 'code-language-tag';
              langTag.textContent = language;
              container.appendChild(langTag);
            }
          }

          // Move the pre element into the container
          pre.parentNode.insertBefore(container, pre);
          container.appendChild(copyButton);
          container.appendChild(pre);
        });

        return wrapper.innerHTML;
      } catch (err) {
        console.error('Error processing markdown:', err);
        console.error('Input was:', markdown.substring(0, 100) + '...');

        if (debugMode) {
          return `
            <p class="error-message">Error rendering content: ${err.message}</p>
            <details>
              <summary style="cursor: pointer; color: #ff4d4d;">Debug: Raw Markdown with Error</summary>
              <pre style="max-height: 400px; overflow: auto; background: #222; padding: 10px; margin-top: 10px;">${markdown.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</pre>
            </details>
          `;
        }

        // Fallback for errors - try to display raw markdown
        return `<p class="error-message">Error rendering content: ${err.message}</p><pre>${markdown.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</pre>`;
      }
    }

    // Helper function for basic markdown processing
    function basicMarkdownProcess(markdown) {
      return markdown
        // Escape HTML
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        // Code blocks
        .replace(/```(\w*)\n([\s\S]*?)```/g, (_, lang, code) => {
          return `<pre><code class="language-${lang}">${code.trim()}</code></pre>`;
        })
        // Headers
        .replace(/^### (.*$)/gm, '<h3>$1</h3>')
        .replace(/^## (.*$)/gm, '<h2>$1</h2>')
        .replace(/^# (.*$)/gm, '<h1>$1</h1>')
        // Bold and italic
        .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
        .replace(/\*(.*?)\*/g, '<em>$1</em>')
        // Lists
        .replace(/^\* (.+)/gm, '<li>$1</li>')
        .replace(/(<li>.*<\/li>)\n/g, '<ul>$1</ul>')
        // Links
        .replace(/\[(.*?)\]\((.*?)\)/g, '<a href="$2">$1</a>')
        // Paragraphs
        .replace(/\n\n/g, '</p><p>');
    }

    // Add copy code functionality
    function setupCodeCopyButtons() {
      try {
        // Find all copy buttons
        const copyButtons = document.querySelectorAll('.copy-code-button');

        if (copyButtons.length === 0) {
          // No code blocks found yet
          return;
        }

        // Use event delegation for better performance
        // Remove existing listeners first to prevent duplicates
        document.removeEventListener('click', handleCopyButtonClick);
        
        // Add a single event listener to handle all copy button clicks
        document.addEventListener('click', handleCopyButtonClick);
        
        // Mark buttons as having a listener (for reference)
        copyButtons.forEach(button => {
          if (!button.getAttribute('data-has-listener')) {
            button.setAttribute('data-has-listener', 'true');
          }
        });
      } catch (err) {
        console.error('Error setting up code copy buttons:', err);
      }
    }
    
    // Handler function for copy button clicks
    function handleCopyButtonClick(event) {
      // Check if the clicked element is a copy button
      if (!event.target.classList.contains('copy-code-button')) return;
      
      try {
        const button = event.target;
        // Find the code element within the container
        const pre = button.nextElementSibling;
        if (!pre || !pre.tagName || pre.tagName.toLowerCase() !== 'pre') {
          console.error('No pre element found');
          return;
        }

        const codeElement = pre.querySelector('code');
        if (!codeElement) {
          console.error('No code element found');
          return;
        }

        let codeText = codeElement.textContent;

        // Make sure we have a string
        if (typeof codeText !== 'string') {
          codeText = String(codeText);
        }

        // Copy the code to clipboard
        navigator.clipboard.writeText(codeText).then(() => {
          // Visual feedback
          button.textContent = 'Copied!';
          button.classList.add('copied');

          // Reset after a short delay
          setTimeout(() => {
            button.textContent = 'Copy';
            button.classList.remove('copied');
          }, 2000);
        }).catch(err => {
          console.error('Failed to copy code: ', err);
          button.textContent = 'Error';

          setTimeout(() => {
            button.textContent = 'Copy';
          }, 2000);
        });
      } catch (err) {
        console.error('Error in copy button handler:', err);
        // Try to recover
        if (event.target) {
          event.target.textContent = 'Error';
          setTimeout(() => {
            event.target.textContent = 'Copy';
          }, 2000);
        }
      }
    }

    // Show notification
    function showNotification(message, type = 'success') {
      const container = document.getElementById('notification-container');
      const notification = document.createElement('div');
      notification.textContent = message;
      notification.className = `notification ${type}`;

      container.appendChild(notification);

      // Get all existing notifications
      const notifications = container.getElementsByClassName('notification');
      const offset = (notifications.length - 1) * 10; // Stack effect

      // Position the new notification
      notification.style.transform = `translateX(50px) translateY(-${offset}px)`;

      // Use requestAnimationFrame for smoother animations
      requestAnimationFrame(() => {
        notification.classList.add('visible');
        notification.style.transform = `translateX(0) translateY(-${offset}px)`;
      });

      // Hide after 1 second
      setTimeout(() => {
        notification.classList.remove('visible');
        notification.style.transform = `translateX(50px) translateY(-${offset}px)`;

        // Remove from DOM after animation completes
        setTimeout(() => {
          notification.remove();
          // Reposition remaining notifications
          Array.from(notifications).forEach((n, i) => {
            n.style.transform = `translateX(0) translateY(-${i * 10}px)`;
          });
        }, 300);
      }, 5000);
    }

    // Show temporary notification that disappears faster
    function showTemporaryNotification(message, type = null) {
      const container = document.getElementById('notification-container');
      const notification = document.createElement('div');
      notification.textContent = message;
      notification.className = 'notification';

      if (type) {
        notification.classList.add(type);
      }

      container.appendChild(notification);

      // Use requestAnimationFrame for smoother animations
      requestAnimationFrame(() => {
        notification.classList.add('visible');
      });

      // Hide after 2 seconds (faster than regular notifications)
      setTimeout(() => {
        notification.classList.remove('visible');

        // Remove from DOM after animation completes
        setTimeout(() => {
          notification.remove();
        }, 300);
      }, 2000);
    }

    // Initialize
    updateModelBadge();

    // Add passive event listeners for better scrolling performance
    const contentContainer = document.getElementById('content-container');
    if (contentContainer) {
      // Throttle scroll events to improve performance and reduce flickering
      let scrollTimeout;
      contentContainer.addEventListener('scroll', () => {
        // Only execute code after scrolling stops
        if (scrollTimeout) {
          clearTimeout(scrollTimeout);
        }
        
        // Temporarily add a class during scrolling to reduce rendering
        contentContainer.classList.add('scrolling');
        
        scrollTimeout = setTimeout(() => {
          // Remove the class after scrolling stops
          contentContainer.classList.remove('scrolling');
        }, 150);
      }, { passive: true });
    }

    // Optimize content container for hardware acceleration
    function optimizeScrollPerformance() {
      const contentContainer = document.getElementById('content-container');
      const resultContent = document.getElementById('result-content');
      
      if (contentContainer) {
        // Use requestAnimationFrame for smoother compositing and reduce flickering
        requestAnimationFrame(() => {
          // Add stable compositing layer
          contentContainer.style.transform = 'translateZ(0)';
          
          // Prevent unnecessary repaints during scroll
          if (resultContent) {
            // Optimize content for static rendering
            resultContent.style.transform = 'translate3d(0,0,0)';
            resultContent.style.contain = 'paint';
          }
        });
      }
    }

    // Call the optimization function on load
    window.addEventListener('load', optimizeScrollPerformance, { passive: true });
    
    // Refresh model badge whenever focus returns to window
    // (e.g., after closing model-selector)
    window.addEventListener('focus', () => {
      updateModelBadge();
    }, { passive: true });
    
    // Listen for postMessage from model-selector window
    window.addEventListener('message', (event) => {
      if (event.data && event.data.type === 'model-settings-updated') {
        updateModelBadge();
      }
    });

    // Handler for continuing with context (add screenshot)
    document.getElementById('btn-add-context').addEventListener('click', () => {
      ipcRenderer.send('add-context-screenshot');
    });

    // Handler for reporting error in solution
    document.getElementById('btn-report-error').addEventListener('click', () => {
      // Ask the user to describe the error
      const errorDescription = prompt('Please describe the error in the solution:');

      if (errorDescription && errorDescription.trim() !== '') {
        ipcRenderer.send('report-solution-error', errorDescription);
      }
    });

    // Update shortcut labels based on platform
    document.querySelectorAll('.shortcut').forEach(el => {
      const text = el.textContent;
      el.textContent = text.replace('‚åò', isMac ? '‚åò' : 'Ctrl');
    });

    // Handle content container visibility
    ipcRenderer.on('hide-content', () => {
      const contentContainer = document.getElementById('content-container');

      // Save references to important elements before clearing
      const banner = document.getElementById('instruction-banner');
      const modelBadge = document.getElementById('model-badge');
      const notificationContainer = document.getElementById('notification-container');

      // Clear the container using more performance-optimized method
      while (contentContainer.firstChild) {
        contentContainer.removeChild(contentContainer.firstChild);
      }

      // Add back the instruction banner
      contentContainer.appendChild(banner);

      // Recreate the main-content structure
      const mainContent = document.createElement('div');
      mainContent.id = 'main-content';

      // Recreate the loading content
      const loadingContent = document.createElement('div');
      loadingContent.id = 'loading-content';
      loadingContent.className = 'loading-container';
      loadingContent.style.display = 'none';

      // Add skeleton sections
      for (let i = 0; i < 3; i++) {
        const section = document.createElement('div');
        section.className = 'skeleton-section';

        const header = document.createElement('div');
        header.className = 'skeleton-header';
        section.appendChild(header);

        // Add some skeleton text lines
        for (let j = 0; j < 3; j++) {
          const textLine = document.createElement('div');
          textLine.className = `skeleton-text line-${Math.floor(70 + Math.random() * 30)}`;
          section.appendChild(textLine);
        }

        // Add a code block to the second section
        if (i === 1) {
          const codeBlock = document.createElement('div');
          codeBlock.className = 'skeleton-code';
          section.appendChild(codeBlock);
        }

        loadingContent.appendChild(section);
      }

      // Add the loading content to main content
      mainContent.appendChild(loadingContent);

      // Create empty result content
      const resultContent = document.createElement('div');
      resultContent.id = 'result-content';
      resultContent.className = 'result-content';
      mainContent.appendChild(resultContent);

      // Recreate context actions container
      const contextActions = document.createElement('div');
      contextActions.id = 'context-actions';
      contextActions.style.display = 'none';

      // Add the buttons
      const addContextBtn = document.createElement('div');
      addContextBtn.className = 'toolbar-button';
      addContextBtn.id = 'btn-add-context';
      addContextBtn.innerHTML = '<span class="icon">üì∑</span><span>Add screenshot to continue</span>';

      const reportErrorBtn = document.createElement('div');
      reportErrorBtn.className = 'toolbar-button';
      reportErrorBtn.id = 'btn-report-error';
      reportErrorBtn.innerHTML = '<span class="icon">üîÑ</span><span>Report error in solution</span>';

      contextActions.appendChild(addContextBtn);
      contextActions.appendChild(reportErrorBtn);
      mainContent.appendChild(contextActions);

      // Add everything back to the container
      contentContainer.appendChild(mainContent);
      contentContainer.appendChild(modelBadge);
      contentContainer.appendChild(notificationContainer);

      // Re-attach event listeners
      document.getElementById('btn-add-context').addEventListener('click', () => {
        ipcRenderer.send('add-context-screenshot');
      });

      document.getElementById('btn-report-error').addEventListener('click', () => {
        const errorDescription = prompt('Please describe the error in the solution:');
        if (errorDescription && errorDescription.trim() !== '') {
          ipcRenderer.send('report-solution-error', errorDescription);
        }
      });
    });

    // Auto-scroll handling with flicker prevention
    function safeScrollToBottom(force = false) {
      const contentContainer = document.getElementById('content-container');
      const isNearBottom = (window.innerHeight + window.scrollY) >= document.body.offsetHeight - 100;
      
      if (force || isNearBottom) {
        // Use requestAnimationFrame to prevent flickering
        requestAnimationFrame(() => {
          // Add class to reduce rendering
          contentContainer.classList.add('scrolling');
          
          // Scroll to bottom
          contentContainer.scrollTo({
            top: contentContainer.scrollHeight,
            behavior: 'auto'
          });
          
          // Remove class after scrolling completes
          setTimeout(() => {
            contentContainer.classList.remove('scrolling');
          }, 100);
        });
      }
    }
  </script>
</body>

</html>