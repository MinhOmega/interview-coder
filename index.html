<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8" />
  <title>Interview Coder</title>
  <link rel="stylesheet" href="styles.css">
</head>

<body>
  <!-- New horizontal floating toolbar at the top -->
  <div class="toolbar" id="top-toolbar">
    <div class="toolbar-button" id="btn-toggle-visibility" title="Show/Hide (Cmd/Ctrl+B)">
      <span class="icon">👁️</span>
      <span>Show/Hide</span>
      <span class="shortcut" id="toggle-shortcut">⌘ B</span>
    </div>

    <div class="toolbar-button" id="btn-process" title="Process Screenshots (Cmd/Ctrl+Enter)">
      <span class="icon">📸</span>
      <span>Process Images</span>
      <span class="shortcut" id="process-shortcut">⌘ ↵</span>
    </div>

    <div class="toolbar-button" id="btn-auto-screenshot" title="Screenshot & Process (Cmd/Ctrl+H)">
      <span class="icon">📷</span>
      <span>Auto Screenshot</span>
      <span class="shortcut">⌘ H</span>
    </div>

    <div class="toolbar-button" id="btn-reset" title="Reset (Cmd/Ctrl+R)">
      <span class="icon">🔄</span>
      <span>Start Over</span>
      <span class="shortcut" id="reset-shortcut">⌘ R</span>
    </div>

    <div class="toolbar-button" id="btn-settings" title="Settings (Cmd/Ctrl+,)">
      <span class="icon">⚙️</span>
      <span>Settings</span>
      <span class="shortcut">⌘ ,</span>
    </div>

    <div class="toolbar-button" id="btn-inspect" title="Inspect Elements (Cmd/Ctrl+Shift+I)">
      <span class="icon">🔍</span>
      <span>Inspect</span>
      <span class="shortcut">⌘ ⇧ I</span>
    </div>
  </div>

  <!-- Content container to separate from toolbar -->
  <div class="content-container" id="content-container">
    <div class="instruction-banner" id="instruction-banner"></div>

    <div id="main-content">
      <!-- Loading skeleton -->
      <div id="loading-content" class="loading-container" style="display: none;">
        <!-- Section 1: Analyzing the Problem -->
        <div class="skeleton-section">
          <div class="skeleton-header"></div>
          <div class="skeleton-text line-90"></div>
          <div class="skeleton-text line-80"></div>
          <div class="skeleton-text line-90"></div>
        </div>

        <!-- Section 2: My thoughts -->
        <div class="skeleton-section">
          <div class="skeleton-header"></div>
          <div class="skeleton-text line-90"></div>
          <div class="skeleton-text line-80"></div>
          <div class="skeleton-code"></div>
          <div class="skeleton-text line-70"></div>
        </div>

        <!-- Section 3: Complexity -->
        <div class="skeleton-section">
          <div class="skeleton-header"></div>
          <div class="skeleton-text line-80"></div>
          <div class="skeleton-text line-90"></div>
        </div>
      </div>

      <!-- Result content -->
      <div id="result-content" class="result-content"></div>

      <!-- Continue with context button section -->
      <div id="context-actions" style="display: none;">
        <div class="toolbar-button" id="btn-add-context">
          <span class="icon">📷</span>
          <span>Add screenshot to continue</span>
        </div>
        <div class="toolbar-button" id="btn-report-error">
          <span class="icon">🔄</span>
          <span>Report error in solution</span>
        </div>
      </div>
    </div>

    <div id="model-badge" class="model-badge"></div>

    <div id="notification-container" class="notification-container"></div>
  </div>

  <script>
    const { ipcRenderer } = require('electron');

    // Import remark and related packages
    let remark = null;
    let remarkGfm = null;
    let remarkHtml = null;
    let remarkProcessor = null;

    try {
      remark = require('remark');
      remarkGfm = require('remark-gfm');
      remarkHtml = require('remark-html');

      // Initialize remark processor
      remarkProcessor = remark()
        .use(remarkGfm)  // Add GitHub Flavored Markdown support
        .use(remarkHtml, {
          sanitize: false  // Allow HTML in the markdown
        });

      console.log("Remark initialized successfully");
    } catch (e) {
      console.error("Error initializing Remark:", e.message);
    }

    // Detect platform for correct key labels
    const isMac = navigator.platform.includes('Mac');
    const modifierKey = isMac ? 'Command' : 'Ctrl';

    // Application state
    let isWindowVisible = true;
    let debugMode = true; // Set to true for debugging

    // Toggle window visibility
    function toggleWindowVisibility() {
      // Simply notify main process about the visibility toggle request
      // Let main process handle the actual hiding/showing
      ipcRenderer.send('toggle-visibility');

      // Local state will be updated when we receive the update-visibility event
    }

    // Listen for main process messages
    ipcRenderer.on('update-instruction', (event, instruction) => {
      const banner = document.getElementById('instruction-banner');
      banner.innerHTML = instruction.replace(/\n/g, '<br>');
      banner.style.opacity = '1';
    });

    // Initialize context menu for element inspection
    document.addEventListener('contextmenu', (e) => {
      ipcRenderer.send('show-context-menu');
    });

    // Register keyboard shortcut for DevTools (Cmd/Ctrl+Shift+I)
    document.addEventListener('keydown', (e) => {
      if ((isMac ? e.metaKey : e.ctrlKey) && e.shiftKey && e.key === 'I') {
        ipcRenderer.send('toggle-devtools');
        e.preventDefault();
      }
    });

    ipcRenderer.on('hide-instruction', () => {
      const banner = document.getElementById('instruction-banner');
      banner.style.opacity = '0';
    });

    ipcRenderer.on('update-visibility', (event, isVisible) => {
      isWindowVisible = isVisible;
      document.body.classList.toggle('invisible-mode', !isWindowVisible);
    });

    ipcRenderer.on('notification', (event, data) => {
      showNotification(data.body, data.type || 'success');
    });

    ipcRenderer.on('warning', (event, message) => {
      showNotification(message, 'warning');
    });

    ipcRenderer.on('error', (event, message) => {
      showNotification(message, 'error');
    });

    ipcRenderer.on('loading', (event, isLoading) => {
      document.getElementById('loading-content').style.display = isLoading ? 'flex' : 'none';
      document.getElementById('result-content').style.display = isLoading ? 'none' : 'block';

      // Show/hide context actions when not loading
      document.getElementById('context-actions').style.display = isLoading ? 'none' : 'flex';
    });

    ipcRenderer.on('analysis-result', async (event, markdown) => {
      const html = await processMarkdown(markdown);
      document.getElementById('result-content').innerHTML = html;

      // Show context actions 
      document.getElementById('context-actions').style.display = 'flex';

      // Setup code copy buttons after content is added
      setupCodeCopyButtons();

      // Scroll to top
      window.scrollTo(0, 0);
    });

    // Setup for streaming results
    ipcRenderer.on('stream-start', () => {
      document.getElementById('result-content').innerHTML = '';
      document.getElementById('context-actions').style.display = 'none';
    });

    // Track current markdown accumulation state for improved streaming
    let streamBuffer = '';
    let codeBlockType = null;
    let insideCodeBlock = false;

    ipcRenderer.on('stream-chunk', async (event, chunk) => {
      try {
        // Add chunk to buffer
        streamBuffer += chunk;

        // Process the full accumulated text to ensure proper markdown rendering
        const html = await processMarkdown(streamBuffer);
        document.getElementById('result-content').innerHTML = html;

        // Setup code copy buttons
        setupCodeCopyButtons();

        // Auto-scroll to the bottom if user is already at the bottom
        if ((window.innerHeight + window.scrollY) >= document.body.offsetHeight - 100) {
          window.scrollTo(0, document.body.scrollHeight);
        }
      } catch (error) {
        console.error("Error processing stream chunk:", error);
        // Display error but continue operation
        document.getElementById('result-content').innerHTML += `<p class="error">Error rendering chunk: ${error.message}</p>`;
      }
    });

    ipcRenderer.on('stream-update', async (event, fullText) => {
      // Replace the content with the full updated text (better for Gemini streaming)
      try {
        console.log("Received stream update, length:", fullText.length);
        // Update the stream buffer
        streamBuffer = fullText;

        // If the text is empty, don't process it
        if (!fullText || fullText.trim() === '') {
          return;
        }

        const html = await processMarkdown(fullText);
        document.getElementById('result-content').innerHTML = html;

        // Setup code copy buttons after content is updated
        setupCodeCopyButtons();

        // Auto-scroll to the bottom if user is already at the bottom
        if ((window.innerHeight + window.scrollY) >= document.body.offsetHeight - 100) {
          window.scrollTo(0, document.body.scrollHeight);
        }
      } catch (error) {
        console.error("Error processing stream update:", error);
        // Provide better error visualization
        document.getElementById('result-content').innerHTML = `
          <p class="error">Error rendering content: ${error.message}</p>
          <pre>${fullText.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</pre>
        `;
      }
    });

    ipcRenderer.on('stream-end', () => {
      // Streaming is complete, reset buffer
      console.log("Stream ended");
      streamBuffer = '';

      // Make sure all code blocks have copy buttons
      setupCodeCopyButtons();

      // Show context actions when streaming is complete
      document.getElementById('context-actions').style.display = 'flex';

      // Hide instruction banner when streaming is complete
      const banner = document.getElementById('instruction-banner');
      banner.style.opacity = '0';

      // Add a small scroll to ensure visible buttons if needed
      const resultContent = document.getElementById('result-content');
      if (resultContent.scrollHeight > resultContent.clientHeight) {
        resultContent.scrollBy({ top: 1, behavior: 'smooth' });
      }
    });

    ipcRenderer.on('clear-result', () => {
      document.getElementById('result-content').innerHTML = '';
      document.getElementById('context-actions').style.display = 'none';
    });

    // Listen for DevTools toggle notification
    ipcRenderer.on('devtools-toggled', (event, isOpen) => {
      if (isOpen) {
        showNotification('DevTools opened. Inspect elements by clicking on them.', 'success');
      } else {
        showNotification('DevTools closed', 'success');
      }
    });

    // Update AI provider/model badge display
    ipcRenderer.on('model-changed', () => {
      updateModelBadge();
    });

    // Handle screen sharing detection
    ipcRenderer.on('screen-sharing-detected', () => {
      // Make the window nearly invisible
      isWindowVisible = false;
      document.body.classList.add('invisible-mode');

      // Show temporary notification
      showTemporaryNotification('Screen sharing detected - window hidden. Press ' + modifierKey + '+B to show.', 'warning');
    });

    // Update the model badge with current settings
    async function updateModelBadge() {
      try {
        let settings;

        try {
          settings = await ipcRenderer.invoke('get-current-settings');
        } catch (error) {
          console.error('Error getting model settings from main process:', error);

          // Try to get settings from localStorage as fallback
          try {
            const savedSettings = localStorage.getItem('model-settings');
            if (savedSettings) {
              settings = JSON.parse(savedSettings);
              console.log('Retrieved settings from localStorage:', settings);
            } else {
              // Fallback to default settings
              settings = {
                aiProvider: 'openai',
                currentModel: 'gpt-4o-mini'
              };
            }
          } catch (localStorageErr) {
            console.error('Error retrieving from localStorage:', localStorageErr);
            // Fallback to default settings
            settings = {
              aiProvider: 'openai',
              currentModel: 'gpt-4o-mini'
            };
          }
        }

        const badge = document.getElementById('model-badge');

        let providerName = '';
        switch (settings.aiProvider) {
          case 'openai': providerName = 'OpenAI'; break;
          case 'ollama': providerName = 'Ollama'; break;
          case 'gemini': providerName = 'Gemini'; break;
          default: providerName = settings.aiProvider || 'AI';
        }

        const modelName = settings.currentModel || 'Default Model';
        badge.textContent = `${providerName}: ${modelName}`;

        // Save current settings to localStorage for persistence
        try {
          localStorage.setItem('model-settings', JSON.stringify(settings));
        } catch (err) {
          console.error('Error saving settings to localStorage:', err);
        }
      } catch (error) {
        console.error('Error updating model badge:', error);
        // Ensure badge always shows something useful even on complete failure
        const badge = document.getElementById('model-badge');
        badge.textContent = 'AI: Default Model';
      }
    }

    // Process markdown content to HTML using Remark
    async function processMarkdown(markdown) {
      try {
        // Check if we have any content to process
        if (!markdown || markdown.trim() === '') {
          return '';
        }

        // Debug logging
        if (debugMode) {
          console.log("Processing markdown input:", markdown);
        } else {
          console.log("Processing markdown, length:", markdown.length);
        }

        // Pre-process the markdown for better rendering
        let processedMarkdown = markdown;
        let html = '';

        console.log("🚀 ~ processMarkdown ~ remarkProcessor:", remarkProcessor)
        if (remarkProcessor) {
          // Use Remark to process markdown
          try {
            const vFile = await remarkProcessor.process(processedMarkdown);
            html = String(vFile);
            console.log("Successfully processed with Remark");
          } catch (remarkError) {
            console.error("Remark processing error:", remarkError);
            throw remarkError;
          }
        } else {
          console.log("Fallback: Using basic markdown processing");
          // Basic fallback markdown processing
          html = processedMarkdown
            // Escape HTML
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            // Code blocks with language
            .replace(/```(\w+|[\w\-\.]+)\n([\s\S]*?)```/g, (_, lang, code) => {
              return `<pre><code class="language-text">${code.trim()}</code></pre>`;
            })
            // Code blocks without language
            .replace(/```\n([\s\S]*?)```/g, (_, code) => {
              return `<pre><code class="language-text">${code.trim()}</code></pre>`;
            })
            // Headers
            .replace(/^### (.*$)/gm, '<h3>$1</h3>')
            .replace(/^## (.*$)/gm, '<h2>$1</h2>')
            .replace(/^# (.*$)/gm, '<h1>$1</h1>')
            // Bold and italic
            .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
            .replace(/\*(.*?)\*/g, '<em>$1</em>')
            // Lists
            .replace(/^\* (.+)/gm, '<li>$1</li>')
            .replace(/(<li>.*<\/li>)\n/g, '<ul>$1</ul>')
            // Links
            .replace(/\[(.*?)\]\((.*?)\)/g, '<a href="$2">$1</a>')
            // Paragraphs
            .replace(/\n\n/g, '</p><p>');

          // Wrap in paragraphs if not already wrapped
          if (!html.startsWith('<')) {
            html = '<p>' + html + '</p>';
          }
        }

        // If debug mode is on, add raw markdown visibility
        if (debugMode) {
          return `
            <div style="background: rgba(0,0,0,0.8); padding: 10px; margin-bottom: 10px; border-radius: 5px;">
              <details>
                <summary style="cursor: pointer; color: #ffcc00;">Debug: Raw Markdown (Click to expand)</summary>
                <pre style="max-height: 200px; overflow: auto; background: #222; padding: 10px; margin-top: 10px;">${processedMarkdown.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</pre>
              </details>
            </div>
            ${html}
          `;
        }

        // Add copy buttons to code blocks and language tags
        const wrapper = document.createElement('div');
        wrapper.innerHTML = html;

        // Find all pre > code elements and wrap them with copy button and language tag
        wrapper.querySelectorAll('pre > code').forEach(codeBlock => {
          const pre = codeBlock.parentNode;

          // Check if this pre is already wrapped in a code-block-container
          if (pre.parentNode && pre.parentNode.className === 'code-block-container') {
            return; // Skip if already wrapped
          }

          const container = document.createElement('div');
          container.className = 'code-block-container';

          // Move the pre element into the container
          pre.parentNode.insertBefore(container, pre);
          container.appendChild(pre);

          // Create copy button
          const copyButton = document.createElement('button');
          copyButton.className = 'copy-code-button';
          copyButton.textContent = '';  // Empty since we're using ::before pseudo-element
          copyButton.title = 'Copy code to clipboard';
          container.appendChild(copyButton);

          // Extract language from class
          let language = '';
          if (codeBlock.className) {
            const langMatch = codeBlock.className.match(/language-(\w+)/);
            if (langMatch && langMatch[1]) {
              language = langMatch[1];

              // Create language tag
              const langTag = document.createElement('div');
              langTag.className = 'code-language-tag';
              langTag.textContent = language;
              container.appendChild(langTag);

              // Simple syntax highlighting for comments
              if (['js', 'javascript', 'typescript', 'ts', 'java', 'csharp', 'cs', 'cpp', 'c', 'php'].includes(language)) {
                // Apply basic highlighting for comments
                const codeContent = codeBlock.innerHTML;
                codeBlock.innerHTML = codeContent
                  // Highlight single line comments
                  .replace(/(\/\/.*?)(?:\n|$)/g, '<span class="comment">$1</span>\n')
                  // Highlight multi-line comments
                  .replace(/(\/\*[\s\S]*?\*\/)/g, '<span class="comment">$1</span>');
              }
            }
          }

          // Ensure pre has proper styling
          pre.style.margin = '0';
        });

        // Process inline code elements (not inside pre tags)
        wrapper.querySelectorAll('code').forEach(codeElement => {
          // Skip if this is inside a pre (already handled above)
          if (codeElement.parentNode.tagName.toLowerCase() === 'pre') {
            return;
          }

          // Add class for inline code
          codeElement.classList.add('inline-code');
        });

        return wrapper.innerHTML;
      } catch (err) {
        console.error('Error processing markdown:', err);
        console.error('Input was:', markdown.substring(0, 100) + '...');

        if (debugMode) {
          return `
            <p class="error">Error rendering content: ${err.message}</p>
            <details>
              <summary style="cursor: pointer; color: #ff4d4d;">Debug: Raw Markdown with Error</summary>
              <pre style="max-height: 400px; overflow: auto; background: #222; padding: 10px; margin-top: 10px;">${markdown.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</pre>
            </details>
          `;
        }

        // Fallback for errors - try to display raw markdown
        return `<p class="error">Error rendering content: ${err.message}</p><pre>${markdown.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</pre>`;
      }
    }

    // Add copy code functionality
    function setupCodeCopyButtons() {
      try {
        // Find all copy buttons
        const copyButtons = document.querySelectorAll('.copy-code-button');

        if (copyButtons.length === 0) {
          // No code blocks found yet
          return;
        }

        console.log(`Setting up ${copyButtons.length} code copy buttons`);

        copyButtons.forEach(button => {
          // Skip if the button already has a listener (check for data attribute)
          if (button.getAttribute('data-has-listener') === 'true') {
            return;
          }

          // Add the click event listener
          button.addEventListener('click', function () {
            try {
              // Find the container
              const container = this.closest('.code-block-container');
              if (!container) {
                console.error('No container found');
                return;
              }

              // Find the pre element
              const pre = container.querySelector('pre');
              if (!pre) {
                console.error('No pre element found');
                return;
              }

              const codeElement = pre.querySelector('code');
              if (!codeElement) {
                console.error('No code element found');
                return;
              }

              let codeText = codeElement.textContent;

              // Make sure we have a string
              if (typeof codeText !== 'string') {
                codeText = String(codeText);
              }

              // Copy the code to clipboard
              navigator.clipboard.writeText(codeText).then(() => {
                // Visual feedback
                this.textContent = '';  // Keep empty since we're using ::before
                this.classList.add('copied');

                // Reset after a short delay
                setTimeout(() => {
                  this.textContent = '';  // Keep empty
                  this.classList.remove('copied');
                }, 2000);
              }).catch(err => {
                console.error('Failed to copy code: ', err);
                this.classList.add('error');

                setTimeout(() => {
                  this.classList.remove('error');
                }, 2000);
              });
            } catch (err) {
              console.error('Error in copy button handler:', err);
              // Try to recover
              this.classList.add('error');
              setTimeout(() => {
                this.classList.remove('error');
              }, 2000);
            }
          });

          // Mark the button as having a listener
          button.setAttribute('data-has-listener', 'true');
        });
      } catch (err) {
        console.error('Error setting up code copy buttons:', err);
      }
    }

    // Show notification
    function showNotification(message, type = 'success') {
      const container = document.getElementById('notification-container');
      const notification = document.createElement('div');
      notification.textContent = message.replace(/\n/g, '<br>');
      notification.className = `notification ${type}`;

      container.appendChild(notification);

      // Get all existing notifications
      const notifications = container.getElementsByClassName('notification');
      const offset = (notifications.length - 1) * 10; // Stack effect

      // Position the new notification
      notification.style.transform = `translateX(50px) translateY(-${offset}px)`;

      // Trigger reflow to ensure animation works
      void notification.offsetWidth;
      notification.classList.add('visible');
      notification.style.transform = `translateX(0) translateY(-${offset}px)`;

      // Hide after 1 second
      setTimeout(() => {
        notification.classList.remove('visible');
        notification.style.transform = `translateX(50px) translateY(-${offset}px)`;

        // Remove from DOM after animation completes
        setTimeout(() => {
          notification.remove();
          // Reposition remaining notifications
          Array.from(notifications).forEach((n, i) => {
            n.style.transform = `translateX(0) translateY(-${i * 10}px)`;
          });
        }, 300);
      }, 1000);
    }

    // Show temporary notification that disappears faster
    function showTemporaryNotification(message, type = null) {
      const container = document.getElementById('notification-container');
      const notification = document.createElement('div');
      notification.textContent = message;
      notification.className = 'notification';

      if (type) {
        notification.classList.add(type);
      }

      container.appendChild(notification);

      // Trigger reflow to ensure animation works
      void notification.offsetWidth;
      notification.classList.add('visible');

      // Hide after 2 seconds (faster than regular notifications)
      setTimeout(() => {
        notification.classList.remove('visible');

        // Remove from DOM after animation completes
        setTimeout(() => {
          notification.remove();
        }, 300);
      }, 2000);
    }

    // Register for keyboard events to handle shortcuts
    document.addEventListener('keydown', (e) => {
      // Allow event to propagate to text fields
      if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
        return;
      }

      // Handle DevTools shortcut (already defined above)
      if ((isMac ? e.metaKey : e.ctrlKey) && e.shiftKey && e.key === 'I') {
        return; // This is handled by the other event listener
      }

      // Don't process if some modifier keys are pressed (to avoid conflicts)
      if (e.altKey || e.shiftKey) return;

      const ctrlOrCmd = isMac ? e.metaKey : e.ctrlKey;

      // If Ctrl/Cmd key is pressed
      if (ctrlOrCmd) {
        // When window is invisible, only handle Command/Ctrl + B
        if (!isWindowVisible) {
          if (e.key === 'b') {
            toggleWindowVisibility();
            e.preventDefault();
          }
          return;
        }

        // Handle all shortcuts when window is visible
        switch (e.key) {
          case 'b': // Toggle visibility
            toggleWindowVisibility();
            e.preventDefault();
            break;

          case 'Enter': // Process screenshots
            ipcRenderer.send('process-screenshots');
            e.preventDefault();
            break;

          case 'r': // Reset
            ipcRenderer.send('reset-process');
            e.preventDefault();
            break;

          case 'q': // Quit
            ipcRenderer.send('quit-app');
            e.preventDefault();
            break;
        }
      }
    });

    // Initialize
    updateModelBadge();

    // Refresh model badge whenever focus returns to window
    // (e.g., after closing model-selector)
    window.addEventListener('focus', () => {
      console.log('Window focused, refreshing model badge');
      updateModelBadge();
    });

    // Listen for postMessage from model-selector window
    window.addEventListener('message', (event) => {
      if (event.data && event.data.type === 'model-settings-updated') {
        console.log('Received settings update from model selector:', event.data.settings);
        updateModelBadge();
      }
    });

    // Setup toolbar button handlers
    document.getElementById('btn-toggle-visibility').addEventListener('click', () => {
      toggleWindowVisibility();
    });

    document.getElementById('btn-process').addEventListener('click', () => {
      ipcRenderer.send('process-screenshots');
    });

    document.getElementById('btn-auto-screenshot').addEventListener('click', () => {
      ipcRenderer.send('auto-screenshot');
    });

    document.getElementById('btn-reset').addEventListener('click', () => {
      ipcRenderer.send('reset-process');
    });

    document.getElementById('btn-settings').addEventListener('click', () => {
      ipcRenderer.send('open-settings');
    });

    // Handler for inspect button
    document.getElementById('btn-inspect').addEventListener('click', () => {
      ipcRenderer.send('toggle-devtools');
    });

    // Handler for continuing with context (add screenshot)
    document.getElementById('btn-add-context').addEventListener('click', () => {
      ipcRenderer.send('add-context-screenshot');
    });

    // Handler for reporting error in solution
    document.getElementById('btn-report-error').addEventListener('click', () => {
      // Ask the user to describe the error
      const errorDescription = prompt('Please describe the error in the solution:');

      if (errorDescription && errorDescription.trim() !== '') {
        ipcRenderer.send('report-solution-error', errorDescription);
      }
    });

    // Update shortcut labels based on platform
    document.querySelectorAll('.shortcut').forEach(el => {
      const text = el.textContent;
      // Replace Mac command symbol with Ctrl for non-Mac platforms
      el.textContent = text
        .replace('⌘', isMac ? '⌘' : 'Ctrl')
        .replace('⇧', isMac ? '⇧' : 'Shift');
    });

    // Handle content container visibility
    ipcRenderer.on('hide-content', () => {
      const contentContainer = document.getElementById('content-container');
      
      // Save references to important elements before clearing
      const banner = document.getElementById('instruction-banner');
      const modelBadge = document.getElementById('model-badge');
      const notificationContainer = document.getElementById('notification-container');
      
      // Clear the container
      contentContainer.innerHTML = '';
      
      // Add back the instruction banner
      contentContainer.appendChild(banner);
      
      // Recreate the main-content structure
      const mainContent = document.createElement('div');
      mainContent.id = 'main-content';
      
      // Recreate the loading content
      const loadingContent = document.createElement('div');
      loadingContent.id = 'loading-content';
      loadingContent.className = 'loading-container';
      loadingContent.style.display = 'none';
      
      // Add skeleton sections
      for (let i = 0; i < 3; i++) {
        const section = document.createElement('div');
        section.className = 'skeleton-section';
        
        const header = document.createElement('div');
        header.className = 'skeleton-header';
        section.appendChild(header);
        
        // Add some skeleton text lines
        for (let j = 0; j < 3; j++) {
          const textLine = document.createElement('div');
          textLine.className = `skeleton-text line-${Math.floor(70 + Math.random() * 30)}`;
          section.appendChild(textLine);
        }
        
        // Add a code block to the second section
        if (i === 1) {
          const codeBlock = document.createElement('div');
          codeBlock.className = 'skeleton-code';
          section.appendChild(codeBlock);
        }
        
        loadingContent.appendChild(section);
      }
      
      // Add the loading content to main content
      mainContent.appendChild(loadingContent);
      
      // Create empty result content
      const resultContent = document.createElement('div');
      resultContent.id = 'result-content';
      resultContent.className = 'result-content';
      mainContent.appendChild(resultContent);
      
      // Recreate context actions container
      const contextActions = document.createElement('div');
      contextActions.id = 'context-actions';
      contextActions.style.display = 'none';
      
      // Add the buttons
      const addContextBtn = document.createElement('div');
      addContextBtn.className = 'toolbar-button';
      addContextBtn.id = 'btn-add-context';
      addContextBtn.innerHTML = '<span class="icon">📷</span><span>Add screenshot to continue</span>';
      
      const reportErrorBtn = document.createElement('div');
      reportErrorBtn.className = 'toolbar-button';
      reportErrorBtn.id = 'btn-report-error';
      reportErrorBtn.innerHTML = '<span class="icon">🔄</span><span>Report error in solution</span>';
      
      contextActions.appendChild(addContextBtn);
      contextActions.appendChild(reportErrorBtn);
      mainContent.appendChild(contextActions);
      
      // Add everything back to the container
      contentContainer.appendChild(mainContent);
      contentContainer.appendChild(modelBadge);
      contentContainer.appendChild(notificationContainer);
      
      // Re-attach event listeners
      document.getElementById('btn-add-context').addEventListener('click', () => {
        ipcRenderer.send('add-context-screenshot');
      });
      
      document.getElementById('btn-report-error').addEventListener('click', () => {
        const errorDescription = prompt('Please describe the error in the solution:');
        if (errorDescription && errorDescription.trim() !== '') {
          ipcRenderer.send('report-solution-error', errorDescription);
        }
      });
    });
  </script>
</body>

</html>